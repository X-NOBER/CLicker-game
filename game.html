<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>p5.js Clicker â€” Animated Edition</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1020;color:#e6eef8;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #defaultCanvas0{display:block;margin:0 auto}
    .ui-sans{font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .hint{position:fixed;left:12px;bottom:12px;opacity:.8}
  </style>
</head>
<body>
  <div class="hint ui-sans">Click the monster! Press <strong>U</strong> to toggle upgrades. <strong>R</strong> to reset.</div>

<script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
<script>
// --- CONFIG ---
const GAME_WIDTH = 960;
const GAME_HEIGHT = 640;

let player = {
  gold: 0,
  dps: 0,
  clickPower: 1,
  critChance: 0.05
};

let enemy;
let particles = [];
let floats = [];
let upgrades = [];
let showUpgrades = true;
let lastAutoTick = 0;

function setup(){
  createCanvas(GAME_WIDTH, GAME_HEIGHT);
  pixelDensity(1);
  initEnemy();
  initUpgrades();
}

function initEnemy(){
  enemy = {
    maxHp: 1000,
    hp: 1000,
    wobble: 0,
    wSpeed: 0.02,
    size: 220,
    regenTimer: 0
  };
}

function initUpgrades(){
  upgrades = [
    {id:1,name:'Power Click', cost:10, level:0, max:50, effect:()=>{player.clickPower += 1}, anim:0},
    {id:2,name:'Auto Tap', cost:100, level:0, max:20, effect:()=>{player.dps += 2}, anim:0},
    {id:3,name:'Criticals', cost:450, level:0, max:10, effect:()=>{player.critChance = min(0.75, player.critChance + 0.02)}, anim:0},
    {id:4,name:'Big Swing', cost:2000, level:0, max:5, effect:()=>{player.clickPower += 25}, anim:0}
  ];
}

function draw(){
  backgroundGradient();
  drawParallaxBG();
  drawHUD();
  drawEnemy();
  updateParticles();
  updateFloats();
  updateAutoDamage();
}

function backgroundGradient(){
  for(let y=0;y<height;y++){
    let t = y/height;
    let c = lerpColor(color('#071024'), color('#0f345b'), t);
    stroke(c); line(0,y,width, y);
  }
}

// Simple parallax animated blobs
let bgOffset=0;
function drawParallaxBG(){
  bgOffset += 0.002;
  push();
  translate(width/2, height/2 + 60);
  noStroke();
  for(let i=0;i<6;i++){
    let s = 140 + i*80;
    let off = sin(frameCount*0.01 + i)*40;
    fill(255, 255, 255, 8 - i);
    ellipse(off + sin(frameCount*0.01*i)*40, -i*20, s + sin(frameCount*0.03+i)*20, s*0.6);
  }
  pop();
}

function drawHUD(){
  // Gold
  push();
  fill(255); textSize(20); textAlign(LEFT); text('Gold: ' + Math.floor(player.gold), 18, 30);
  text('DPS: ' + player.dps, 18, 56);
  text('Click: ' + player.clickPower, 18, 82);
  pop();

  // Upgrades panel
  if(showUpgrades){
    drawUpgradesPanel();
  }
}

function drawUpgradesPanel(){
  const w = 300; const h = 260; const x = width - w - 18; const y = 18;
  push();
  fill(10, 14, 30, 220); stroke(255, 15); strokeWeight(1);
  rect(x,y,w,h,12);
  noStroke(); fill(200); textSize(18); textAlign(LEFT); text('Upgrades', x+12, y+28);

  for(let i=0;i<upgrades.length;i++){
    let u = upgrades[i];
    let bx = x+12; let by = y+44 + i*52; let bw = w - 24; let bh = 44;
    // floating animation
    u.anim = lerp(u.anim, 0, 0.08);
    if(u.hover) u.anim = 8;
    push();
    translate(0, u.anim);
    stroke(255,10); fill(255,255,255,6); rect(bx,by,bw,bh,8);
    fill(230); textSize(14); text(u.name + ' x' + u.level, bx+12, by+18);
    fill(160); textSize(12); text('Cost: ' + Math.floor(u.cost), bx+12, by+34);
    // buy button
    let btnx = bx + bw - 82; let btny = by + 8; let btnw = 70; let btnh = 28;
    if(mouseIsInRect(btnx,btny,btnw,btnh)){
      fill(0,150,255); u.hover = true;
    } else { fill(255,255,255,14); u.hover = false; }
    rect(btnx,btny,btnw,btnh,6);
    fill(10); textAlign(CENTER, CENTER); text('Buy', btnx+btnw/2, btny+btnh/2+1);
    pop();
  }
  pop();
}

function mousePressed(){
  // clicking enemy area
  let ex = width/2; let ey = height/2 - 20; let r = enemy.size/2;
  if(dist(mouseX,mouseY,ex,ey) < r){
    doClickDamage(mouseX,mouseY);
  }
  // upgrades buy check
  if(showUpgrades){
    const w = 300; const x = width - w - 18; const y = 18;
    for(let i=0;i<upgrades.length;i++){
      let bx = x+12; let by = y+44 + i*52; let bw = w - 24; let bh = 44;
      let btnx = bx + bw - 82; let btny = by + 8; let btnw = 70; let btnh = 28;
      if(mouseIsInRect(btnx,btny,btnw,btnh)){
        buyUpgrade(upgrades[i]);
      }
    }
  }
}

function doClickDamage(mx,my){
  // crit check
  let isCrit = random() < player.critChance;
  let amt = player.clickPower * (isCrit ? 3 : 1);
  enemy.hp = max(0, enemy.hp - amt);
  spawnParticles(mx, my, amt, isCrit);
  spawnFloat(mx, my - 20, Math.floor(amt) + (isCrit? '!' : ''));
  // enemy reaction
  enemy.wobble = 18;
  player.gold += amt;
}

function spawnParticles(x,y,amt,crit){
  let n = constrain(6 + floor(sqrt(amt)), 6, 50);
  for(let i=0;i<n;i++){
    particles.push(new Particle(x, y, crit));
  }
}

function spawnFloat(x,y,txt){
  floats.push(new Floaty(x,y,txt));
}

function updateAutoDamage(){
  // autos every second
  if(millis() - lastAutoTick > 1000){
    if(player.dps > 0){
      enemy.hp = max(0, enemy.hp - player.dps);
      player.gold += player.dps;
      spawnFloat(width/2, height/2 - 40, '-' + player.dps);
    }
    lastAutoTick = millis();
  }
}

function buyUpgrade(u){
  if(player.gold >= u.cost && u.level < u.max){
    player.gold -= u.cost;
    u.level++;
    // scale cost
    u.cost = floor(u.cost * 1.6 + u.level * 2);
    // apply immediate effect
    if(u.id===1) player.clickPower += 1;
    if(u.id===2) player.dps += 2;
    if(u.id===3) player.critChance = min(0.75, player.critChance + 0.02);
    if(u.id===4) player.clickPower += 25;
    u.anim = -6; // pop animation
    spawnParticles(mouseX || width-150, mouseY || 60, 8, false);
  }
}

function drawEnemy(){
  push();
  translate(width/2, height/2 - 20);
  // wobble
  enemy.wobble = lerp(enemy.wobble, 0, 0.12);
  let wob = sin(frameCount * enemy.wSpeed) * 6 + enemy.wobble * 0.4;

  // shadow
  push();
  translate(0, enemy.size*0.34);
  fill(0, 0, 0, 80);
  ellipse(0,0, enemy.size * 1.05 + sin(frameCount*0.05)*6, enemy.size*0.35);
  pop();

  // body with breathing animation
  let hpRatio = enemy.hp/enemy.maxHp;
  let pul = map(sin(frameCount*0.04), -1,1,0.94,1.06);
  let bodySize = enemy.size * pul * (1 + (1-hpRatio)*0.12);
  noStroke();
  // colorful layered body
  for(let i=0;i<4;i++){
    let s = bodySize * (1 - i*0.12);
    fill(120 + i*30, 60 + i*20, 200 - i*20, 220 - i*30);
    ellipse(wob*0.8, -i*6, s, s*0.9);
  }

  // eyes and face anim
  let eyeY = map(hpRatio, 0,1,6,-8);
  fill(255); ellipse(-30 + wob*0.5, eyeY, 36, 24);
  ellipse(30 + wob*0.5, eyeY, 36, 24);
  fill(20); ellipse(-30 + wob*0.5, eyeY, 12, 12);
  ellipse(30 + wob*0.5, eyeY, 12, 12);

  // mouth
  fill(10); arc(0, 26 + wob*0.2, bodySize*0.5, 60 + (1-hpRatio)*40, 0, PI);

  // HP bar over head
  push(); translate(0, -bodySize*0.62);
  drawHpBar(enemy.hp, enemy.maxHp, 240, 12);
  pop();

  pop();

  // if dead, respawn slowly with animation
  if(enemy.hp <= 0){
    enemy.regenTimer += deltaTime;
    if(enemy.regenTimer > 1600){
      // regenerated with stronger hp
      let bonus = floor(1 + random()*3);
      enemy.maxHp = max(100, floor(enemy.maxHp * (1 + random()*0.15)));
      enemy.hp = enemy.maxHp;
      enemy.regenTimer = 0;
      // reward player
      player.gold += floor(enemy.maxHp*0.25);
      // explosion particles
      for(let i=0;i<80;i++) particles.push(new Particle(width/2, height/2 - 20, true));
    }
  }
}

function drawHpBar(hp, maxhp, w, h){
  let x = -w/2;
  stroke(255,40); strokeWeight(1); fill(255,12); rect(x-2, -4, w+4, h+8, 8);
  noStroke();
  fill(120, 200, 80);
  let ratio = constrain(hp/maxhp, 0,1);
  rect(x, 0, w*ratio, h, 6);
  fill(255); textSize(12); textAlign(CENTER, CENTER);
  text(Math.floor(hp) + ' / ' + Math.floor(maxhp), 0, h/2 + 2);
}

// --- Particles system ---
class Particle{
  constructor(x,y,crit=false){
    this.pos = createVector(x + random(-8,8), y + random(-8,8));
    this.vel = p5.Vector.fromAngle(random(TWO_PI)).mult(random(1,6));
    this.life = random(400, 1400);
    this.age = 0;
    this.size = random(3,8) * (crit?2:1);
    this.crit = crit;
    this.col = color(random(150,255), random(120,255), random(80,220), 240);
  }
  update(dt){
    this.age += dt;
    this.pos.add(p5.Vector.mult(this.vel, dt/16));
    this.vel.mult(0.96);
  }
  draw(){
    let t = constrain(this.age / this.life, 0,1);
    push(); noStroke();
    let alpha = map(t, 0,1, 255, 0);
    fill(red(this.col), green(this.col), blue(this.col), alpha);
    ellipse(this.pos.x, this.pos.y, this.size * (1 - t) * 1.8);
    pop();
  }
  isDead(){return this.age >= this.life}
}

function updateParticles(){
  for(let i=particles.length-1;i>=0;i--){
    let p = particles[i]; p.update(deltaTime);
    p.draw();
    if(p.isDead()) particles.splice(i,1);
  }
}

// Floating damage numbers
class Floaty{
  constructor(x,y,txt){ this.x=x; this.y=y; this.txt=txt; this.t=0; this.r=random(-0.6,0.6)}
  update(dt){ this.t += dt/800; this.y -= dt/220; }
  draw(){ push(); translate(this.x + sin(this.t*6)*6, this.y);
    textAlign(CENTER); textSize(18 + sin(this.t*6)*3); fill(255, 220 - this.t*240);
    stroke(0, 80); strokeWeight(3); text(this.txt, 0, 0);
    pop(); }
}
function updateFloats(){ for(let i=floats.length-1;i>=0;i--){ floats[i].update(deltaTime); floats[i].draw(); if(floats[i].t>1.4) floats.splice(i,1);} }

function mouseIsInRect(x,y,w,h){ return mouseX >= x && mouseX <= x+w && mouseY >= y && mouseY <= y+h; }

function keyPressed(){
  if(key === 'U' || key === 'u') showUpgrades = !showUpgrades;
  if(key === 'R' || key === 'r') resetGame();
}

function resetGame(){
  player.gold = 0; player.dps = 0; player.clickPower = 1; player.critChance = 0.05; initEnemy(); initUpgrades(); particles = []; floats = [];
}

// tiny helper: constrain mimics p5's constrain but as function
function min(a,b){ return a<b?a:b; }
function max(a,b){ return a>b?a:b; }
function constrain(v, a, b){ return v<a?a:(v>b?b:v); }

// prevent context menu on right click
window.addEventListener('contextmenu', e => e.preventDefault());
</script>
</body>
</html>
